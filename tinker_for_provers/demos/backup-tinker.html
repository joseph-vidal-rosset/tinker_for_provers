<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>SWI-Tinker</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/codemirror.css">
  <link rel="stylesheet" href="tinker.css">
  <link rel="stylesheet" href="term.css">
  <link rel="stylesheet" href="source.css">
  <script src="matchbrackets.js"></script>
  <link rel="icon" type="image/x-icon" href="https://www.swi-prolog.org/download/logo/swipl-64x64.ico">
  <script crossorigin="anonymous" async defer src="https://buttons.github.io/buttons.js"></script>

  <style>
.CodeMirror, .cm-editor, .cm-content {
    font-size: 16px !important;
    font-family: 'Monaco', 'Menlo', monospace !important;
}

.console textarea,
.console input[type="text"],
.tinker-console textarea,
.tinker-console input[type="text"] {
    font-size: 16px !important;
    font-family: 'Monaco', 'Menlo', monospace !important;
}

#png-display {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 9999;
    background: white;
    border: 3px solid #333;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    padding: 20px;
    max-width: 90%;
    max-height: 90%;
    overflow: auto;
}

#png-display img {
    max-width: 100%;
    cursor: pointer;
}

#png-display .close-btn {
    position: absolute;
    top: 5px;
    right: 10px;
    font-size: 24px;
    cursor: pointer;
    color: #333;
}

.latex-copy-btn {
    display: inline-block;
    margin-left: 10px;
    padding: 2px 8px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    font-size: 11px;
    font-family: sans-serif;
}

.latex-copy-btn:hover {
    background: #45a049;
}

.latex-section-marker {
    display: inline;
}
</style>
</head>
<body>

<div class="header">
  <img id="logo" alt="SWI-Prolog logo" src="https://www.swi-prolog.org/download/logo/swipl-128.png">
  <div>
    This is <a href="https://github.com/SWI-Prolog/tinker" target="_blank">SWI-Tinker</a>:
    <a href="https://www.swi-prolog.org" target="_blank">SWI-Prolog</a> running inside your browser</div>
  <div>Please consult our <a href="https://github.com/SWI-Prolog/tinker/wiki" target="_blank">Wiki for help</a></div>
<div class="github-buttons">
  <a class="github-button" href="https://github.com/SWI-Prolog/tinker" data-color-scheme="no-preference: light; light: light; dark: dark;" data-size="large" data-show-count="true" aria-label="Star SWI-Prolog/tinker on GitHub">Star</a>
</div>
</div>
<div class="content">
  <div id="left">
    <div class="tinker-console"></div>
    <div id="png-display"></div>
  </div>

  <div id="right">
    <div class="tinker-source">
      <div class="source-files">
	<select name="select-file"></select>
	<button name="delete-file">&#128465;</button>
	<button name="new-file">+</button>
	<span class="create-file">
          <input type="text" name="file-name" placeholder="File name">
          <button name="create-button">Create</button>
	</span>
      </div>
      <div class="editor-wrapper">
	<div name="editor"></div>
      </div>
      <div class="source-buttons">
	<button name="consult">(Re)consult</button>
	<span class="exch-files">
	  <input type="file" accept=".pl" multiple class="upload-file">
	  <a class="btn upload" href="#" title="Upload files">üì§</a>
	  <a class="btn download" type="text/x-prolog">&#x1F4E5;</a>
	</span>
      </div>
    </div>
  </div>
</div>

<script src="/wasm/swipl-bundle.js"></script>
<script src="https://cdn.jsdelivr.net/npm/split.js@1.6.5/dist/split.min.js"></script>
<script>
  window.onload = () => {
    if (typeof Split !== 'undefined') {
      Split(['#left', '#right'], { gutterSize: 10 });
    }
  }
</script>
<style>
.gutter {
    background-color: #eee;
    background-repeat: no-repeat;
    background-position: 50%;
    cursor: col-resize;
}
.gutter:hover { background-color: #ddd; }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>

<script type="module">
  import * as tinker from "./tinker.js";
  import * as term from "./term.js";

  let Prolog;
  let Module;
  let Tinker;
  let Term;

  var options = {
    arguments: ['-g', 'true'],
    locateFile: function(file) {
      return '/wasm/' + file;
    },
    on_output: print_output
  };

  function print_output(line, cls, sgr) {
    Tinker.console.print(line, cls, sgr);
  }

  SWIPL(options).then(async (module) => {
    Module = module;
    Prolog = Module.prolog;
    Tinker = new tinker.Tinker({
      root:document.querySelector("div.content"),
      module:module,
      banner:true
    });
    window.prolog = Prolog;
    window.tinker = Tinker;
    Term = new term.Term(Tinker.console.elem);

    // Fonction pour mettre √† jour l'URL bas√©e sur l'input courant
    // La logique de mise √† jour de l'URL a √©t√© d√©plac√©e/consolid√©e dans le script "SOLUTION FINALE"
    // pour √©viter les conflits et les troncatures dues √† une logique concurrente avec un court debounce.

    // Fonction pour attacher les listeners √† l'input de la console
    function attachInputListeners() {
      const consoleInput = document.querySelector('.tinker-console input[type="text"]') ||
                          document.querySelector('.tinker-console textarea');

      if (consoleInput && !consoleInput.dataset.listenersAttached) {
        consoleInput.dataset.listenersAttached = 'true';

        // Les listeners 'input' et 'keydown' ont √©t√© supprim√©s ici
        // car la logique est g√©r√©e de mani√®re plus robuste dans le dernier script.

        console.log('‚úì URL listeners attached to console input (only flag set)');
        return true;
      }
      return false;
    }

    // Essayer d'attacher imm√©diatement
    setTimeout(attachInputListeners, 1000);

    // Observer les changements dans la console pour r√©-attacher si l'input est recr√©√©
    const observer = new MutationObserver(() => {
      const input = document.querySelector('.tinker-console input[type="text"]') ||
                   document.querySelector('.tinker-console textarea');
      if (input && !input.dataset.listenersAttached) {
        attachInputListeners();
      }
    });

    const consoleDiv = document.querySelector('.tinker-console');
    if (consoleDiv) {
      observer.observe(consoleDiv, { childList: true, subtree: true });
    }

    // Fallback: r√©essayer p√©riodiquement
    setInterval(() => {
      const input = document.querySelector('.tinker-console input[type="text"]') ||
                   document.querySelector('.tinker-console textarea');
      if (input && !input.dataset.listenersAttached) {
        attachInputListeners();
      }
    }, 2000);

    window.checkAndExecuteURLQuery();
  });
</script>

<script>
  add_one = (n) => n+1;

  promise_any = (data) => {
    console.log(data);
    return new Promise(function(resolve, reject) {
      resolve(data);
    });
  }

  window.lastQuery = '';

  window.checkAndExecuteURLQuery = function() {
    if (window.location.hash) {
      const query = decodeURIComponent(window.location.hash.substring(1));
      if (query) {
        const waitForConsoleInput = setInterval(() => {
          const consoleInput = document.querySelector('.tinker-console input[type="text"]') ||
                              document.querySelector('.tinker-console textarea');

          if (consoleInput && window.tinker && window.tinker.console) {
            clearInterval(waitForConsoleInput);

            console.log('Console ready, executing query:', query);
            consoleInput.value = query;
            window.lastQuery = query;

            setTimeout(() => {
              // Try to find and call the actual submit function
              if (window.tinker.console.emit) {
                window.tinker.console.emit('submit', query);
              } else if (window.tinker.console.onsubmit) {
                window.tinker.console.onsubmit(query);
              } else {
                // Fallback: simulate Enter event more thoroughly
                consoleInput.focus();
                const events = ['keydown', 'keypress', 'keyup'];
                events.forEach(eventType => {
                  const evt = new KeyboardEvent(eventType, {
                    key: 'Enter',
                    code: 'Enter',
                    keyCode: 13,
                    which: 13,
                    charCode: 13,
                    bubbles: true,
                    cancelable: true
                  });
                  consoleInput.dispatchEvent(evt);
                });
              }
              console.log('Query execution attempted');
            }, 800);
          }
        }, 100);

        setTimeout(() => clearInterval(waitForConsoleInput), 10000);
      }
    }
  };
</script>

<script>
  document.addEventListener('DOMContentLoaded', function() {

    window.latexBlocks = [];

    let lastConsoleContent = '';
    let buttonsAdded = false;

    function extractAllLatexBlocks() {
      const consoleDiv = document.querySelector('.tinker-console');
      if (!consoleDiv) return [];

      const textContent = consoleDiv.textContent || consoleDiv.innerText;
      const blocks = [];

      const prooftrees = textContent.match(/\\begin\{prooftree\}[\s\S]*?\\end\{prooftree\}/g) || [];
      const fitches = textContent.match(/\\begin\{fitch\}[\s\S]*?\\end\{fitch\}/g) || [];

      prooftrees.forEach(block => blocks.push({ type: 'prooftree', code: block }));
      fitches.forEach(block => blocks.push({ type: 'fitch', code: block }));

      return blocks;
    }

    function addCopyButtonsToConsole() {
      const consoleDiv = document.querySelector('.tinker-console');
      if (!consoleDiv) return;

      const currentContent = consoleDiv.textContent || '';

      if (currentContent === lastConsoleContent) return;
      lastConsoleContent = currentContent;
      buttonsAdded = false;

      if (!currentContent.includes('\\begin{prooftree}') && !currentContent.includes('\\begin{fitch}')) {
        return;
      }

      window.latexBlocks = extractAllLatexBlocks();

      if (window.latexBlocks.length === 0 || buttonsAdded) return;

      const walker = document.createTreeWalker(
        consoleDiv,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      const patternsToMatch = [
        { pattern: /^\\end\{prooftree\}$/m, blockType: 'prooftree' },
        { pattern: /^\\end\{fitch\}$/m, blockType: 'fitch' }
      ];

      let prooftreeCount = 0;
      let fitchCount = 0;
      let node;

      while (node = walker.nextNode()) {
        for (const item of patternsToMatch) {
          if (item.pattern.test(node.textContent)) {
            const parent = node.parentElement;

            if (parent && !parent.querySelector('.latex-copy-btn')) {
              const blockIndex = item.blockType === 'prooftree' ? prooftreeCount :
                                 window.latexBlocks.filter(b => b.type === 'prooftree').length + fitchCount;

              if (item.blockType === 'prooftree') prooftreeCount++;
              else fitchCount++;

              const span = document.createElement('span');
              span.className = 'latex-section-marker';
              span.textContent = node.textContent;

              const btn = document.createElement('button');
              btn.className = 'latex-copy-btn';
              btn.textContent = 'üìã Copy LaTeX';
              btn.onclick = function() {
                copyLatexBlock(blockIndex);
              };

              span.appendChild(btn);
              parent.replaceChild(span, node);
              buttonsAdded = true;
              break;
            }
          }
        }
      }
    }

    function copyLatexBlock(index) {
      if (window.latexBlocks[index]) {
        const latex = window.latexBlocks[index].code;
        navigator.clipboard.writeText(latex).then(() => {
          alert('LaTeX code copied to clipboard!');
        }).catch(err => {
          alert('Failed to copy to clipboard');
        });
      }
    }

      /* ancien code
    function shareURL() {
      if (window.lastQuery) {
        const url = window.location.origin + window.location.pathname + '#' + encodeURIComponent(window.lastQuery);
        navigator.clipboard.writeText(url).then(() => {
          alert('Shareable URL copied!\nShare this link to show the same proof.');
        }).catch(() => {
          prompt('Copy this URL:', url);
        });
      } else {
        alert('No query to share. Execute a prove() query first.');
      }
    }
      */

function shareURL() {
      // 1. Tenter de lire la valeur actuelle du champ de saisie
      const consoleInput = document.querySelector('.tinker-console input[type="text"]') ||
                           document.querySelector('.tinker-console textarea');
      // Commencer par la valeur trim√©e de l'input, ou une cha√Æne vide
      let query = consoleInput ? consoleInput.value.trim() : '';

      // 2. LOGIQUE DE REPLI : Si l'input est vide, on utilise la derni√®re requ√™te ex√©cut√©e (window.lastQuery)
      if (!query && window.lastQuery) {
          query = window.lastQuery;
      }

      // 3. Proc√©der UNIQUEMENT si une requ√™te valide existe (actuelle ou en m√©moire)
      if (query) {
        // Mettre √† jour lastQuery pour garantir la synchronisation
        window.lastQuery = query;

        // Encodage de la requ√™te compl√®te (garantit le point et les parenth√®ses finales)
        const url = window.location.origin + window.location.pathname + '#' + encodeURIComponent(query);

        navigator.clipboard.writeText(url).then(() => {
          alert('Shareable URL copied!\nShare this link to show the same proof.');
        }).catch(() => {
          prompt('Copy this URL:', url);
        });
      } else {
        alert('No query to share. Execute a prove() query first.');
      }
    }


    setInterval(addCopyButtonsToConsole, 1000);

    function getLatexByStyle(style) {
      const consoleDiv = document.querySelector('.tinker-console');
      if (!consoleDiv) {
        console.error('‚ùå No console div found');
        return null;
      }

      const textContent = consoleDiv.textContent || consoleDiv.innerText;
      console.log('üìù Console text length:', textContent.length);
      console.log('üîç Looking for style:', style);

      // Debug: afficher les sections trouv√©es
      const hasSequent = textContent.search(/sequent/i) !== -1;
      const hasFitch = textContent.search(/fitch/i) !== -1;
      const hasTree = textContent.search(/tree/i) !== -1;
      console.log('üìå Sections detected: Sequent=' + hasSequent + ', Fitch=' + hasFitch + ', Tree=' + hasTree);

      if (style === 'sequent') {
        // Pour sequent: prendre uniquement entre "Sequent" et "Natural Deduction" ou "Fitch"
        // Chercher la section explicitement marqu√©e "Sequent Calculus"

        const sequentStartMatch = textContent.match(/[-\s]*Sequent\s+Calculus\s*[-\s]*/i);
        if (!sequentStartMatch) {
          console.error('‚ùå No "Sequent Calculus" marker found');
          return null;
        }

        const sequentStart = textContent.indexOf(sequentStartMatch[0]);
        console.log('üìç Sequent starts at position:', sequentStart);

        // Trouver o√π se termine la section Sequent (avant "Natural Deduction" ou "Fitch")
        const naturalDeductionMatch = textContent.substring(sequentStart).search(/[-\s]*Natural\s+Deduction\s*[-\s]*/i);
        const fitchMatch = textContent.substring(sequentStart).search(/[-\s]*a\)\s*Fitch\s+Style/i);

        let sequentEnd;
        if (naturalDeductionMatch !== -1) {
          sequentEnd = sequentStart + naturalDeductionMatch;
          console.log('üìç Natural Deduction found at:', sequentEnd);
        } else if (fitchMatch !== -1) {
          sequentEnd = sequentStart + fitchMatch;
          console.log('üìç Fitch found at:', sequentEnd);
        } else {
          console.error('‚ùå Cannot find end of Sequent section');
          return null;
        }

        const sequentText = textContent.substring(sequentStart, sequentEnd);
        console.log('‚úì Sequent section extracted (length:', sequentText.length + ')');

        const treeMatches = sequentText.match(/\\begin\{prooftree\}[\s\S]*?\\end\{prooftree\}/g);
        console.log('üå≥ Sequent prooftree blocks found:', treeMatches ? treeMatches.length : 0);

        if (treeMatches && treeMatches.length > 0) {
          console.log('‚úÖ Returning', treeMatches.length, 'sequent proofs');
          return treeMatches.join('\n\n\\vspace{1cm}\n\n');
        }
        console.error('‚ùå No prooftree blocks in Sequent section');
        return null;

      } else if (style === 'fitch') {
        // Pour Fitch: chercher entre "Fitch" et "Tree"
        const fitchMatch = textContent.match(/Fitch[\s-]*style[\s\S]*?(?=(?:Tree[\s-]*style|$))/i);
        console.log('üìã Fitch match:', fitchMatch ? 'found' : 'not found');

        if (!fitchMatch) {
          console.error('‚ùå No Fitch section found');
          return null;
        }

        const fitchMatches = fitchMatch[0].match(/\\begin\{fitch\}[\s\S]*?\\end\{fitch\}/g);
        console.log('üìä Fitch blocks found:', fitchMatches ? fitchMatches.length : 0);

        if (!fitchMatches) {
          console.error('‚ùå No fitch LaTeX blocks in Fitch section');
          return null;
        }

        console.log('‚úÖ Returning', fitchMatches.length, 'Fitch proofs');
        return fitchMatches.map(fitch => '\\begin{center}\n' + fitch + '\n\\end{center}').join('\n\n\\vspace{1cm}\n\n');

      } else if (style === 'tree') {
        // Pour Tree: chercher apr√®s "Tree-style" ou "Natural deduction" (Tree)
        const treeMatch = textContent.match(/Tree[\s-]*style[\s\S]*$/i);
        console.log('üå≤ Tree match:', treeMatch ? 'found' : 'not found');

        if (!treeMatch) {
          console.error('‚ùå No Tree section found');
          return null;
        }

        const treeMatches = treeMatch[0].match(/\\begin\{prooftree\}[\s\S]*?\\end\{prooftree\}/g);
        console.log('üå≥ Tree prooftree blocks found:', treeMatches ? treeMatches.length : 0);

        if (treeMatches && treeMatches.length > 0) {
          console.log('‚úÖ Returning', treeMatches.length, 'Tree proofs');
          return treeMatches.join('\n\n\\vspace{1cm}\n\n');
        }
        return null;
      }

      return null;
    }

    // Fonction utilitaire pour debug: afficher le contenu de la console
    window.debugConsoleContent = function() {
      const consoleDiv = document.querySelector('.tinker-console');
      if (!consoleDiv) {
        console.log('No console div');
        return;
      }

      const text = consoleDiv.textContent;
      console.log('=== CONSOLE CONTENT DEBUG ===');
      console.log('Total length:', text.length);

      // Trouver les marqueurs
      const markers = ['sequent', 'Sequent', 'Fitch', 'fitch', 'Tree', 'tree'];
      markers.forEach(marker => {
        const idx = text.indexOf(marker);
        if (idx !== -1) {
          console.log(`\n"${marker}" found at position ${idx}:`);
          console.log(text.substring(Math.max(0, idx - 30), Math.min(text.length, idx + 80)));
        }
      });

      // Compter les blocs LaTeX
      const prooftrees = (text.match(/\\begin\{prooftree\}/g) || []).length;
      const fitches = (text.match(/\\begin\{fitch\}/g) || []).length;
      console.log(`\nLaTeX blocks: ${prooftrees} prooftree(s), ${fitches} fitch block(s)`);

      // Tester les extractions
      console.log('\n=== TESTING EXTRACTIONS ===');
      console.log('Sequent:', getLatexByStyle('sequent') ? '‚úì OK' : '‚úó FAIL');
      console.log('Fitch:', getLatexByStyle('fitch') ? '‚úì OK' : '‚úó FAIL');
      console.log('Tree:', getLatexByStyle('tree') ? '‚úì OK' : '‚úó FAIL');
    };

    function getAllLatexFromConsole() {
      const consoleDiv = document.querySelector('.tinker-console');
      if (!consoleDiv) return null;

      const textContent = consoleDiv.textContent || consoleDiv.innerText;

      const fitchMatches = textContent.match(/\\begin\{fitch\}[\s\S]*?\\end\{fitch\}/g);
      const treeMatches = textContent.match(/\\begin\{prooftree\}[\s\S]*?\\end\{prooftree\}/g);

      const allLatex = [];

      if (treeMatches) {
        treeMatches.forEach(tree => allLatex.push(tree));
      }

      if (fitchMatches) {
        fitchMatches.forEach(fitch => allLatex.push('\\begin{center}\n' + fitch + '\n\\end{center}'));
      }

      return allLatex.length > 0 ? allLatex.join('\n\n\\vspace{1cm}\n\n') : null;
    }

    async function convertProofToPNG(style = 'all') {
      let latexCode;
      let styleName;

      if (style === 'all') {
        latexCode = getAllLatexFromConsole();
        styleName = 'all_proofs';
      } else {
        latexCode = getLatexByStyle(style);
        styleName = style;
      }

      if (!latexCode) {
        alert('No LaTeX proof found for style: ' + style);
        return;
      }

      try {
        const response = await fetch('/wasm/proof_png', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            latex_code: latexCode,
            style: style
          })
        });

        if (!response.ok) {
          throw new Error('HTTP error ' + response.status);
        }

        const data = await response.json();

        if (data.success) {
          const pngDiv = document.getElementById('png-display');
          pngDiv.innerHTML = '';
          pngDiv.style.display = 'block';

          const closeBtn = document.createElement('span');
          closeBtn.className = 'close-btn';
          closeBtn.innerHTML = '√ó';
          closeBtn.onclick = () => {
            pngDiv.innerHTML = '';
            pngDiv.style.display = 'none';
          };

          const img = document.createElement('img');
          img.src = data.image;
          img.alt = 'Proof as PNG (' + styleName + ')';
          img.style.cursor = 'pointer';
          img.onclick = function() {
            const link = document.createElement('a');
            link.href = data.image;
            link.download = 'proof_' + styleName + '_' + Date.now() + '.png';
            link.click();
          };

          pngDiv.appendChild(closeBtn);
          pngDiv.appendChild(img);
        }
      } catch (error) {
        alert('PNG conversion failed for style: ' + style);
      }
    }

    window.convertProofToPNG = convertProofToPNG;
    window.shareProofURL = shareURL;

document.addEventListener('keydown', function(event) {
      // On Linux/Windows: event.ctrlKey, on Mac: event.metaKey (this covers the Super/Cmd key)
      const modifierKey = event.ctrlKey || event.metaKey;

      if (!modifierKey) return; // No modifier pressed, ignore

      const key = event.key.toLowerCase();

      // Ctrl/Cmd + I: All proofs as images (PNG)
      if (key === 'i') {
        event.preventDefault();
        console.log('‚å®Ô∏è  Shortcut triggered: Ctrl/Cmd+i (all Images)');
        convertProofToPNG('all');
        return;
      }

      // Ctrl/Cmd + G: Sequent Calculus proofs (G for G4)
      if (key === 'g') {
        event.preventDefault();
        console.log('‚å®Ô∏è  Shortcut triggered: Ctrl/Cmd+g (sequent calculus G4)');
        convertProofToPNG('sequent');
        return;
      }

      // Ctrl/Cmd + V: Flag-style proofs
      if (key === 'l') {
        event.preventDefault();
        console.log('‚å®Ô∏è  Shortcut triggered: Ctrl/Cmd+l (Fitch styLe)');
        convertProofToPNG('fitch');
        return;
      }

      // Ctrl/Cmd + h : Tree-style proofs (h for Horizontal Proof)
      if (key === 'h') {
        event.preventDefault();
        console.log('‚å®Ô∏è  Shortcut triggered: Ctrl/Cmd+h (Tree-style / Horizontal Proof)');
        convertProofToPNG('tree');
        return;
      }

      // Ctrl/Cmd + a: Share URL adress
      if (key === 'a') {
        event.preventDefault();
        console.log('‚å®Ô∏è  Shortcut triggered: Ctrl/Cmd+a (share URL address)');
        shareURL();
        return;
      }

      // Ctrl/Cmd + k: Debug console content (k for ChecK)
      if (key === 'k') {
        event.preventDefault();
        console.log('‚å®Ô∏è  Shortcut triggered: Ctrl/Cmd+k (debug/checK)');
        if (window.debugConsoleContent) {
          window.debugConsoleContent();
        }
        return;
      }

      // Ctrl/Cmd + u: Force URL update check (for testing)
      if (key === 'u') {
        event.preventDefault();
        console.log('‚å®Ô∏è  Shortcut triggered: Ctrl/Cmd+L (force URL check)');
        const input = document.querySelector('.tinker-console input[type="text"]') ||
                     document.querySelector('.tinker-console textarea');
        if (input) {
          console.log('üìù Current input value:', input.value);
          console.log('üîó Current URL hash:', window.location.hash);
        }
        return;
      }
    });
  });
</script>
<script>
  // Solution avec vidage du cache au bon moment
  setTimeout(() => {
    const updateURLFromConsole = () => {
      const inputs = document.querySelectorAll('input[type="text"], textarea');
      inputs.forEach(input => {
        if (input.parentElement.closest('.tinker-console') && !input.dataset.urlListener) {
          input.dataset.urlListener = 'true';

          input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
              const text = this.value.trim();
              if (text && (text.startsWith('prove(') || text.startsWith('decide('))) {
                // VIDER LE CACHE apr√®s l'ex√©cution
                setTimeout(() => {
                  window.latexBlocks = []; // Vide le cache des blocs LaTeX
                  console.log('üßπ Latex cache cleared after execution');
                }, 2000); // 2 secondes apr√®s l'ex√©cution
              }
            }
          });

          // La logique de mise √† jour de l'URL par input a √©t√© d√©plac√©e/consolid√©e dans le script "SOLUTION FINALE"
          /* input.addEventListener('input', function() {
            setTimeout(() => {
              const text = this.value.trim();
              if (text && (text.startsWith('prove(') || text.startsWith('decide('))) {
                window.location.hash = '#' + encodeURIComponent(text);
                window.lastQuery = text;
              }
            }, 500);
          }); */

          console.log('‚úÖ URL listener added to console input');
        }
      });
    };

    updateURLFromConsole();
    setInterval(updateURLFromConsole, 2000);
  }, 3000);
</script>
<script>
  // SOLUTION FINALE - D√©tection intelligente URL vs user input
// √Ä ajouter APR√àS le chargement de Tinker (avant </body>)

(function() {
  'use strict';

  let lastExecutedQuery = '';
  let loadedFromURL = false;

  // D√©tecter si on charge depuis une URL avec hash
  if (window.location.hash) {
    loadedFromURL = true;
    const urlQuery = decodeURIComponent(window.location.hash.substring(1));
    lastExecutedQuery = urlQuery; // Marquer cette query comme "d√©j√† vue"
    console.log('üîó Loading from URL:', urlQuery);

    // Apr√®s le chargement r√©ussi, r√©initialiser
    setTimeout(() => {
      loadedFromURL = false;
      console.log('‚úÖ URL loading complete, clearing now enabled');
    }, 8000); // 8 secondes de gr√¢ce
  }

  // Fonction pour vider VRAIMENT la console
  function clearConsoleOutput() {
    const consoleDiv = document.querySelector('.tinker-console');
    if (!consoleDiv) return;

    console.log('üßπ Clearing console...');

    // M√©thode 1: Utiliser l'API Tinker si disponible
    if (window.tinker && window.tinker.console) {
      if (typeof window.tinker.console.clear === 'function') {
        window.tinker.console.clear();
        console.log('‚úÖ Console cleared via Tinker API');
        return;
      }
    }

    // M√©thode 2: Supprimer manuellement les √©l√©ments de sortie
    const allChildren = Array.from(consoleDiv.children);
    allChildren.forEach(child => {
      // Garder seulement les inputs
      if (child.tagName !== 'INPUT' && child.tagName !== 'TEXTAREA') {
        // V√©rifier si l'√©l√©ment contient un input
        const hasInput = child.querySelector('input, textarea');
        if (!hasInput) {
          child.remove();
        }
      }
    });

    console.log('‚úÖ Console cleared manually');
  }

  // Attacher le listener sur TOUS les inputs de la console
  function attachClearListener() {
    const inputs = document.querySelectorAll('.tinker-console input[type="text"], .tinker-console textarea');

    inputs.forEach(input => {
      if (input.dataset.clearListenerAttached) return;
      input.dataset.clearListenerAttached = 'true';

      input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          const query = this.value.trim();

          // Si c'est une nouvelle requ√™te prove() ou decide()
          if (query && (query.startsWith('prove(') || query.startsWith('decide('))) {

            // Mettre √† jour l'URL et lastQuery IMM√âDIATEMENT (POINT DE CORRECTION CL√â)
            window.lastQuery = query;
            window.location.hash = '#' + encodeURIComponent(query);
            console.log('üîó URL updated on Enter:', window.location.hash);

            // Si c'est diff√©rent de la derni√®re requ√™te ex√©cut√©e
            if (query !== lastExecutedQuery) {
              console.log('üÜï New query detected:', query);

              // IMPORTANT: Ne pas vider si on vient de charger depuis URL
              if (!loadedFromURL) {
                console.log('üßπ Clearing console (user typed new query)');
                // VIDER LA CONSOLE
                setTimeout(() => {
                  clearConsoleOutput();
                }, 10);
              } else {
                console.log('‚è≠Ô∏è  Skipping clear (loaded from URL)');
                // D√©sactiver le flag apr√®s cette ex√©cution
                setTimeout(() => {
                  loadedFromURL = false;
                  console.log('‚úÖ URL query executed, clearing now enabled');
                }, 2000);
              }

              lastExecutedQuery = query;
            } else {
              console.log('‚Ü©Ô∏è  Same query as before, no clear needed');
            }
          }
        }
      });

      // Aussi mettre √† jour l'URL pendant la frappe (debounce)
      let inputTimeout;
      input.addEventListener('input', function() {
        clearTimeout(inputTimeout);
        inputTimeout = setTimeout(() => {
          const query = this.value.trim();
          if (query && (query.startsWith('prove(') || query.startsWith('decide('))) {
            window.lastQuery = query;
            window.location.hash = '#' + encodeURIComponent(query);
            console.log('üîó URL updated on Input (debounce):', window.location.hash);
          }
        }, 800); // ‚¨ÖÔ∏è D√âLAI DE 800ms pour √©viter la troncature
      });

      console.log('‚úÖ Clear listener attached to input');
    });
  }

  // Observer pour r√©-attacher quand de nouveaux inputs apparaissent
  const observer = new MutationObserver(() => {
    attachClearListener();
  });

  const consoleDiv = document.querySelector('.tinker-console');
  if (consoleDiv) {
    observer.observe(consoleDiv, { childList: true, subtree: true });
  }

  // Attacher r√©guli√®rement
  setInterval(attachClearListener, 2000);

  // Premi√®re tentative
  setTimeout(attachClearListener, 1000);

  console.log('üöÄ Console clearing system initialized with URL protection');
  })();
</script>
<script>
// CORRESPONDANCE PARENTH√àSES POUR LA CONSOLE
function checkParenthesesBalance(input) {
    const value = input.value;
    const openParens = (value.match(/\(/g) || []).length;
    const closeParens = (value.match(/\)/g) || []).length;
    
    // Retirer les anciennes classes
    input.classList.remove('parens-unbalanced', 'parens-highlight');
    
    // Ajouter la classe appropri√©e
    if (openParens !== closeParens) {
        input.classList.add('parens-unbalanced');
    }
    if (value.includes('(') || value.includes(')')) {
        input.classList.add('parens-highlight');
    }
}

function enhanceConsoleInputs() {
    const inputs = document.querySelectorAll('.tinker-console input[type="text"], .tinker-console textarea, .tinker-input input');
    
    inputs.forEach(input => {
        if (input.hasAttribute('data-parenthesis-enhanced')) return;
        input.setAttribute('data-parenthesis-enhanced', 'true');
        
        // V√©rifier imm√©diatement
        checkParenthesesBalance(input);
        
        // V√©rifier √† chaque frappe
        input.addEventListener('input', function() {
            checkParenthesesBalance(this);
        });
    });
}

// Surveiller en permanence
setInterval(enhanceConsoleInputs, 1000);
document.addEventListener('DOMContentLoaded', enhanceConsoleInputs);
</script>
</body>
</html>
